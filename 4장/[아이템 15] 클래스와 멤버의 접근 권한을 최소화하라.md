## [아이템 15] 클래스와 멤버의 접근 권한을 최소화하라
### 1. 소프트웨어 설계 근간이 되는 원리, 캡슐화(정보은닉)
- 잘 설계된 소프트웨어 컴포넌트는 **캡슐화**가 잘 되어 있다.
- API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는 설계를 의미한다.

### 2. 캡슐화(정보은닉)의 장점
- 개발, 테스트, 최적화, 적용, 분석, 수정을 **독립적**으로 가능하게 한다.
  - 병렬 개발 가능
  - 디버깅 및 유지보수 용이
  - 재사용성 증가
  - 개별 컴포넌트 동작 검증 용이

### 3. 자바에서 캡슐화를 구현하는 핵심 장치, 접근제한자
- default 접근제한자
  - 인터페이스: `public`
  - 기타 멤버: `package-private`
- 멤버 접근성 축소 제약
  - 메서드를 재정의할 때, 접근 수준을 상위 클래스보다 좁게 설정할 수 없다. (좁게 설정하면 컴파일 에러 발생)
- 접근 제어의 중요성
  - 접근 제한자를 좁게 설정했었다가, `public` 등으로 권한을 자주 풀어주어야 한다면 컴포넌트 분해를 더 해야 하는 것이 아닌지 고민이 필요하다.
  - 멤버의 접근 수준을 `pakcage-private` 보다 넓게 풀어주는 순간, 그 멤버에 접근할 수 있는 대상의 범위가 매우 넓어지며 공개 API이므로 영원히 지원돼야 한다.
- 따라서, 테스트만을 위해 private 멤버를 `pakcage-private` 이상으로 풀어주는 것은 안 된다.
- 또한, `public` 클래스의 인스턴스 필드는 되도록 `public`이 아니어야 한다.
  - public 가변 필드를 갖는 클래스: thread-safety 하지 않다.
  - public 불변 필드를 갖는 클래스: `final`로 선언된 필드는 참조의 불변성을 보장하지만, 참조하는 객체의 내부 상태는 여전히 변경될 수 있기 때문에, 반드시 기본 타입 값이나 불변 객체를 참조해야 한다.
    - 불변 객체 참조:
        ```java
        public class Example {
            public static final List<String> MY_LIST = List.of("A", "B", "C");
        }
        ```
        - 한계: 내부 구현 변경 필요 시 (외부에서 해당 필드를 참조하고 있을 수 있으므로) 해당 필드를 제거하는 방식으로 리팩토링 하기 힘들다.

    - 가변 객체 참조:
        ```java
        public class Example {
            public static final List<String> MY_LIST = new ArrayList<>(Arrays.asList("A", "B", "C"));
        }
        ```
        - 주의: 배열 필드
          - 길이가 0이 아닌 배열은 모두 변경 가능하므로, 클래스에서 `public static final` 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공하는 것은 피해야 한다.
          - 이를 방지하기 위해 배열을 `private`으로 만들고, 배열의 복사본을 반환하는 `public` 메서드를 제공하는 방어적 복사를 사용한다.

### 4. 접근제한자와 자바 9 모듈 시스템
- 패키지 공개 여부 설정:
  - 자바 9에서 도입된 **모듈 시스템**은 `module-info.java` 파일에서 모듈이 공개할 패키지를 선언한다.
  - `protected` 또는 `public` 멤버라도 패키지가 공개되지 않으면 모듈 외부에서는 접근할 수 없다.
  - 모듈의 JAR 파일을 자신의 모듈 경로가 아닌 애플리케이션 클래스패스에 두면, 모듈 내부의 모든 패키지는 모듈이 없는 것처럼 동작하며, 모듈 밖에서 모든 `public` 및 `protected` 멤버에 접근할 수 있다.
- 모듈 사용의 복잡성:
  - 모듈을 효과적으로 사용하기 위해서는 패키지들을 모듈 단위로 묶고, 의존성을 명시하며, 소스 트리를 재배치해야 한다.
  - 따라서, jdk 외에도 모듈 개념이 널리 받아들여질지 예측하기는 이른 감이 있다.
> #### MSA vs Java9의 모듈 시스템
> MSA는 애플리케이션 아키텍처의 관점에서 널리 사용되며, 모듈 시스템(‘module’이라는 키워드로 정의)은 특정 환경에서 유용하게 사용되는 도구라는 점에서 차이를 보인다.
>
### 5. 결론
- 최소한의 `public` API를 제공하자.
- `public` 클래스는 상수용 `public static final` 필드 외에는 `public` 필드를 갖지 않도록 설계하는 것이 좋다.
- `public static final` 필드가 참조하는 객체가 불변인지 확인하고, 가변 객체를 참조하는 경우에는 주의가 필요하다.
- 이렇게 접근 권한을 최소화하고 정보를 은닉함으로써 소프트웨어의 유지보수성과 재사용성을 높일 수 있다.
