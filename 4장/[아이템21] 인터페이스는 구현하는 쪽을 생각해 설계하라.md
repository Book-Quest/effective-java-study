## 인터페이스에 메서드를 추가하기

자바 8 이전: 인터페이스에 새로운 메서드 추가 불가

but, 자바 8부터 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드가 생김

⇒ 핵심 인터페이스들에도 디폴트 메서드가 추가됨

**생각할 수 있는 모든 상황에서 불변식을 해치지 않고 디폴트 메서드를 작성하기란 어려운 법이다**

(8 이전에서는 인터페이스에 새로운 메서드를 추가가 불가하다고 가정하고 코드가 작성되어 있기 때문에 충돌이 생기는 경우가 있다는 것 같음)

ex) 자바 8의 Collection 인터페이스에 추가된 `removeIf` 

| default boolean | removeIf​(Predicate<? super E> filter) | 주어진 조건을 만족하는 이 컬렉션의 모든 요소를 제거합니다 |
| --- | --- | --- |

```java
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;
    
    for (Iterator<E> it = iterator(); it.hasNext(); ) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
```

코드는 removeIf의 구현 예시이다.

## 디폴트 메서드의 추가로 인해 에러가 나는 예시

아파치의 커먼즈 라이브러리 클래스인 `apache.commons.collections4.collection.SynchronizedCollection` 과 java.util의 `Collections.synchronizedCollection` 정적 팩터리 메서드가 반환하는 클래스와 비슷하다.

비슷한점)

아파치 버전은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공

⇒ 모든 메서드에서 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스

아파치의 `SynchronizedCollection` 클래스는 removeIf를 재정의 하고 있지 않음.

그래서 자바 8버전에서 이를 사용하게 되어 removeIf의 디폴트 구현을 상속받는다면 메서드 호출을 알아서 동기화 해주지 못함.

⇒ 락 객체 사용 불가

- 락 객체란?

여러 스레드가 공유 자원에 접근할 때 동시성 문제를 해결하기 위해 사용되는 동기화 기법

락을 사용하면 한 번에 하나의 스레드만 특정 자원에 접근할 수 있도록 제어 가능

`SynchronizedCollection`  인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 removeIf로 호출하면 `ConcurrentModificationException`이 발생하거나 에러가 날 수 있음

- 자바 플랫폼 라이브러리의 조치

구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 함.

즉, 위의 예시의 경우 removeIf를 재정의하고, 이를 호출하는 다른 메서들은 디폴트 구현을 호출하기 전 동기화를 하도록 함.

## 인터페이스에 디폴트 메서드 활용시 유의할 점

- 디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있음.

자바 8에서 컬렉션 인터페이스에 꽤 많은 디폴트 메서드를 추가했고, 기존 코드에 영향을 미치기 때문.

- 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 경우는 지양해야 함

추가하려는 디폴트 메서드가 기존 구현체들과 충돌할 수 있기 때문.

- 새로운 인터페이스를 만드는 경우, 디폴트 메서드를 활용하는 것은 유용함.

표준적인 메서드 구현을 제공하는데, 그 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해줌.

## Summary

인터페이스를 설계할 때는 디폴트 메서드라는 새로운 도구가 생겼다고 해도 세심한 주의를 기울여야 한다.

기존 인터페이스에 새로운 메서드를 추가하면 잠재적 위험도가 높아지기 때문이다.
