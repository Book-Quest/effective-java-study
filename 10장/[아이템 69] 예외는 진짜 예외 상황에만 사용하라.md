# 예외를 잘못 사용하는 경우

```java
try {
	int i = 0;
	while (true)
		range[i++].climb();
} catch (ArrayIndexOutOfBoundsExceptions e) {
}
```

반복문을 이용해 배열의 원소를 순회하는 코드, 무한루프를 돌다가 끝에 도달하면 `ArrayIndexOutOfBoundsException`이 발생해 끝남.

```java
for (Mountain m : range)
	m.climb();
```

## 잘못된 코드를 작성한 근거

이렇게 반복문으로 작성하면 되는 코드를 왜 저렇게 작성했을까?

⇒ 잘못된 추론을 근거로 성능을 높이기 위해

1. JVM은 배열에 접근할 때 경계를 넘지 않는지 검사
2. 일반적인 반복문도 계열의 경계에 도달하면 종료

⇒ 즉, 두가지를 전부 실행하면 같은 일이 중복되므로 하나를(일반적인 반복문)을 생략

## 잘못된 추론인 이유

- 예외는 정말 예외인 상황에만 사용하게 설계되었기 때문에 최적화 되지 않았을 가능성이 큼 (성능)
- 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한됨
- 배열을 순회하는 표준 관용구는 중복 검사를 수행하지 않음 (JVM이 알아서 최적화해 없애줌)

 

⇒ 성능을 떨어트리고, 제대로 동작하지 않을 수 있음.

예를 들어 반복문안에 다른 에러가 있음에도 불구하고 정해놓은 예외처리로 인해 뭐가 원인인지 알 수 없게 됨.

**⇒ 예외는 오직 예외 상황에서만 써야하며, 일상적인 제어 흐름용으로 쓰여서는 안됨.**

## 예외를 잘못 사용하면 안되는 이유

- 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 머리를 쓰는 기법은 자제할 것.
- 실제로 성능이 좋아지더라도, 자바가 업그레이드 되며 자체 최적화가 더 성능이 좋을 것.
- 버그를 찾기 어려워지고 유지보수가 어려워질 가능성이 있기 때문에 자제하는 것이 좋음.

# API 설계에서의 예외처리

잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

**특정 상태**에서만 호출할 수 있는 **상태 의존**적 메서드를 제공하는 **상태 검사** 메서드도 함께 제공해야 한다.

```java
for (Interator<Foo> i = collcetion.iterator(); i.hasNext(); ) {
	Foo foo = i.next();
	...
}
```

**Iterator 인터페이스**

- 상태 의존적 메서드: next
- 상태 검사 메서드: hasNext

---

### 1. **상태 의존적 메서드: `next()`**

- **의미**: `next()` 메서드는 **현재 상태에 의존**하여 호출 시 동작이 달라질 수 있는 메서드입니다. 이 메서드는 내부 상태(예: 현재 커서 위치)에 따라 다음 요소를 반환하고, 커서를 다음 위치로 이동시킵니다.
- **특징**:
    - 호출하기 전에 **반드시 `hasNext()`로 확인**해야 합니다. 그렇지 않으면 더 이상 반환할 요소가 없을 때 `NoSuchElementException`이 발생할 수 있습니다.
    - 호출하면 내부 상태가 바뀝니다(커서가 이동).
- **예제**:
    
    ```java
    Iterator<String> iterator = list.iterator();
    while (iterator.hasNext()) {
        String element = iterator.next(); // 현재 상태에서 다음 요소를 반환하고 커서를 이동
        System.out.println(element);
    }
    ```
    

---

### 2. **상태 검사 메서드: `hasNext()`**

- **의미**: `hasNext()` 메서드는 현재 상태를 검사하여, **다음에 반환할 요소가 존재하는지 여부**를 확인합니다.
- **특징**:
    - 내부 상태를 변경하지 않습니다(즉, 상태를 읽기만 함).
    - 반환 값은 `boolean` 타입으로, 요소가 남아 있다면 `true`, 없으면 `false`를 반환합니다.
    - `next()`를 호출하기 전에 항상 호출하여, 요소가 남아 있는지 확인하는 것이 일반적입니다.
- **예제**:
    
    ```java
    if (iterator.hasNext()) {
        String element = iterator.next(); // 안전하게 next() 호출 가능
    }
    ```
    

---

Iterator가 상태 검사 메서드인 hasNext를 제공하지 않았다면 클라이어트가 이를 대신 구현해야 한다.

```java
try {
	Iterator<Foo> i = collcetion.interator();
	while (true) {
		Foo foo = i.next();
		...
	}
} catch (NoSuchElementException e) {
}
```

이 코드 역시 반복문에 예외를 사용하면 장황하고 헷갈리며 속도도 느리고, 엉뚱한 곳에 발생한 버그를 숨긴다.

## 상태 검사 메서드, 옵셔널, 특정 값을 이용하는 법

### 옵셔널, 특정 값을 사용해야 하는 경우

- 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변하는 경우(상태 검사 메서드-상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문)
- 성능이 중요한 상황에서 상태 검사 메서드-상태 의존 메서드의 작업 일부를 중복수행하는 경우

### 이외의 경우 (상태 검사 메서드 방식을 사용해야 하는 경우)

- 이외의 경우에는 상태 검사 메서드 방식이 가독성이 더 좋고, 잘못 사용했을 때 발견하기 쉬움
- 상태 검사 메서드 호출을 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 찾기 쉬움

# Summary

예외는 예외 상황에서 쓸 의도로 설계.

정상적인 제어 흐름에서 사용해서는 안됨.

이를 프로그래머에게 강요하는 API를 만들어서도 안됨.
