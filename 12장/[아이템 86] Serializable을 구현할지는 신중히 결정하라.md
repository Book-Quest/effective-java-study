# Serializable을 신중하게 해야하는 이유

직렬화는 클래스 선언에 `implements Serializable`  를 붙이면 간단하게 가능

but, Serialiazable을 구현하면 릴리스한 뒤에는 수정하기 어려움

왜냐하면, 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 되기 때문

## Serializable을 잘못 사용하게 된다면?

- 커스텀 직렬화 형태를 설계하지 않고, 자바의 기본 방식을 사용하면 클래스 내부 구현 방식에 영원히 묶임
- private 인스턴스 필드들마저 API로 공개되어 캡슐화가 깨지게 됨
- 나중에 코드를 수정하면 원래의 직렬화 형태와 달라지게 됨
- ex) 구버전 인스턴스 직렬화 하고, 신버전 인스턴스 역직렬화  (에러 발생)

## 직렬화가 클래스 개선에 제약이 되는 경우

직렬화 가능 클래스를 만드려면 고품질의 직렬화 형태도 주의해서 함께 설계해야 함

하지만 잘 설계해도 클래스를 개선하는 데 제약이 될 수 있음

**ex) 직렬버전 UID(serial version UID)**

```java
//모든 직렬화된 클래스는 고유 식별 번호를 부여받음
static final long serialVersionUID;
```

이를 명시하지 않으면 시스템이 런타임에 암호 해시 함수(SHA-1)를 적용해 자동으로 클래스 안에 생성해 넣음

이 과정에서 클래스 멤버들이 (클래스 이름, 구현한 인터페이스들, 컴파일러가 자동으로 생성해 넣은 것) 고려됨

⇒ 나중에 이를 수정하면 직렬 버전 UID값도 변함

즉, 자동 생성값에 의존하면 호환성이 깨져 `InvalidClassException`이 발생

## 버그와 보안 구멍이 생길 위험

- 직렬화는 우회해서 객체를 생성하는 기법
- 역직렬화는 기존 방식을 따르건, 재정의하거나 일반 생성자의 문제가 그대로 적용되는 **숨은 생성자**
- 전면에 드러나지 않기 때문에 불변식 깨짐과 허가되지 않은 접근을 관리하는 것을 잊게됨

## 신버전을 릴리스할 때 테스트할 것이 늘어남

- 직렬화 가능 클래스가 수정된 경우, 신버전 인스턴스를 직렬화한 후에 구버전으로 역직렬화할 수 있는지, 그 반대도 가능한지 테스트해야 함
- 즉, 테스트해야 할 양이 직렬화 가능 클래스의 수와 릴리스 횟수에 비례해 증가
- 양방향 직렬화/역직렬화가 모두 성공하고, 객체 복제가 잘 되는지 테스트 해야 함 (커스텀 직렬화를 잘 설계 했다면 테스트 부담 감소)

# Serializable을 구현할 때 고려해야 할 사항

- 객체를 전송, 저장할 때 자바 직렬화를 이용하는 프레임워크용으로 만든 클래스라면 직렬화를 해야함
- 하지만 Serializable 구현에 따라는 비용들이 있기 때문에 설계시 득실을 고려해서 선택해야 함
- 일반적으로 `BigInteger`, `Instant` 같은 **‘값’** 클래스와 컬렉션 클래스들은 구현, 스레드 풀처럼 **‘동작’**하는 객체를 표현하는 클래스들은 구현 안함
- 상속용으로 설계된 클래스, 인터페이스도 Serializable을 사용하면 안됨(확장, 구현에 부담이 가기 때문에)

## 상속용으로 설계된 클래스 중 Serializable을 구현한 예

- `Throwable`: 서버가 RMI를 통해 클라이언트로 예외를 보내기 위해 구현
- `Component`: GUI를 전송, 저장, 복원하기 위해 구현(거의 안쓰임)

## 클래스의 인스턴스 필드가 직렬화, 확장이 모두 가능한 경우 주의할 점

- 불변식을 보장해야 한다면, 하위 클래스에 finalize 메서드를 재정의하지 못하게 해야함
- 즉, finalize 메서드를 자신이 재정의하면서 final로 선언하면 됨(finalizer 공격을 막을 수 있음)

---

`finalize`  란?

자바에서 객체가 더 이상 사용되지 않고 **가비지 컬렉션(Garbage Collection)** 대상이 될 때 호출되는 메서드

객체가 메모리에서 제거되기 전에 **정리 작업(cleanup)**을 수행할 기회를 제공

```java
protected void finalize() throws Throwable {
    // 객체가 제거되기 전에 수행할 작업
}
```

- 가비지 컬렉터(Garbage Collector)가 객체를 메모리에서 제거하기 전에 자동으로 호출
- 단, 가비지 컬렉션은 JVM이 필요하다고 판단할 때만 발생하므로, **`finalize`가 언제 호출될지는 보장되지는 않음**

---

- 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 readObjetNoData 메서드를 추가해야 함

```java
private void readObjectNoData() throws InvalidObjectExcepion {
	throw new InvalidObjectException("스트림 데이터가 필요합니다");
}
```

## Serializable을 구현하지 않기로 정한 경우

- 상속용 클래스인데 직렬화를 지원하지 않으면, 하위 클래스에서 직렬화를 지원하려 할 때 부담이 늘어남.
- 역직렬화하려면 상위 클래스는 매개변수가 없는 생성자를 제공해야 하나, 그렇지 않은 경우 직렬화 프록시 패턴을 사용해야 함
- 내부 클래스는 직렬화를 구현하지 말아야 함. (컴파일러가 생성한 필드들이 자동으로 추가되어 기본 직렬화 형태가 분명하지 않기 때문, 정적 멤버는 직렬화 구현 가능)

# Summary

Serializable은 구현한다고 선언하기는 아주 쉽지만, 눈속임일 뿐.

한 클래스의 여러 버전이 상호작용할 일이 없고, 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등

보호된 환경에서만 쓰일 클래스가 아니라면, Serializable 구현은 아주 신중하게 이루어져야함.

상속할 수 있는 클래스라면 주의사항이 더욱 많아짐.
